# Apple Music Module Documentation

## Overview

The Apple Music module (`apple.py`) handles all interactions with the Apple Music API. Unlike Spotify, Apple Music uses a two-tier authentication system with Developer Tokens and User Tokens.

## Dependencies

- `requests`: HTTP client for API calls
- `PyJWT`: For generating developer tokens
- `applemusicpy` (optional): Community library for Apple Music API

## Authentication

### Two-Token System

Apple Music API requires two tokens:

1. **Developer Token** (Server-to-Server)
   - JWT token signed with your private key
   - Valid for up to 6 months
   - Generated by you, not Apple

2. **Music User Token** (User Authorization)
   - Obtained via MusicKit JS or OAuth-like flow
   - Represents user's permission
   - Expires and must be refreshed

### Setup Process

#### 1. Create Developer Token

Requirements:
- Apple Developer Account ($99/year)
- MusicKit identifier from Apple Developer portal
- Private key (.p8 file) from Apple

**Generate Token:**
```python
import jwt
import time

def generate_developer_token(team_id: str, key_id: str, private_key_path: str) -> str:
    """Generate Apple Music developer token (JWT)."""

    with open(private_key_path, 'r') as f:
        private_key = f.read()

    # Token expires in 6 months (max allowed)
    expiration = int(time.time()) + (180 * 24 * 60 * 60)

    headers = {
        'alg': 'ES256',
        'kid': key_id
    }

    payload = {
        'iss': team_id,  # Apple Developer Team ID
        'iat': int(time.time()),
        'exp': expiration
    }

    token = jwt.encode(payload, private_key, algorithm='ES256', headers=headers)
    return token
```

**Configuration:**
```yaml
apple_music:
  team_id: "ABC123DEF4"
  key_id: "XYZ987WVU6"
  private_key_path: "~/.musicdiff/apple_music_key.p8"
```

#### 2. Obtain Music User Token

User must authenticate via:
- MusicKit JS in browser (recommended)
- Manual OAuth-like flow

MusicDiff will open a local web page with MusicKit JS to obtain the token.

## API Interface

### Class: `AppleMusicClient`

Main class for Apple Music operations.

```python
class AppleMusicClient:
    def __init__(self, developer_token: str, user_token: str = None, storefront: str = "us")
    def authenticate_user(self) -> str  # Returns user_token
    def fetch_library_playlists(self) -> List[Playlist]
    def fetch_library_songs(self) -> List[Track]
    def fetch_library_albums(self) -> List[Album]
    def create_playlist(self, name: str, description: str = "") -> str
    def add_tracks_to_playlist(self, playlist_id: str, track_ids: List[str]) -> bool
    def remove_tracks_from_playlist(self, playlist_id: str, track_ids: List[str]) -> bool
    def delete_playlist(self, playlist_id: str) -> bool
    def add_to_library(self, track_ids: List[str]) -> bool
    def remove_from_library(self, track_ids: List[str]) -> bool
    def search_track(self, isrc: str = None, query: str = None) -> Optional[Track]
```

## Core Methods

### `fetch_library_playlists()`

Retrieves all playlists from user's library.

**Endpoint:** `GET /v1/me/library/playlists`

**Returns:** List of `Playlist` objects

**Implementation:**
```python
def fetch_library_playlists(self) -> List[Playlist]:
    """Fetch all user library playlists."""
    playlists = []
    url = f"{self.BASE_URL}/v1/me/library/playlists"
    headers = self._get_headers()

    params = {
        'limit': 100,
        'include': 'tracks'
    }

    while url:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()

        for item in data['data']:
            # Parse playlist
            playlist = self._parse_playlist(item)

            # Fetch full track data for playlist
            tracks = self._fetch_playlist_tracks(item['id'])
            playlist.tracks = tracks

            playlists.append(playlist)

        # Handle pagination
        url = data.get('next')
        params = None  # Next URL includes params

    return playlists
```

---

### `fetch_library_songs()`

Retrieves all songs from user's library (equivalent to Spotify's "Liked Songs").

**Endpoint:** `GET /v1/me/library/songs`

**Returns:** List of `Track` objects

**Implementation:**
```python
def fetch_library_songs(self) -> List[Track]:
    """Fetch all songs in user's library."""
    tracks = []
    url = f"{self.BASE_URL}/v1/me/library/songs"
    headers = self._get_headers()

    params = {'limit': 100}

    while url:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()

        for item in data['data']:
            track = self._parse_track(item)
            tracks.append(track)

        url = data.get('next')
        params = None

    return tracks
```

---

### `create_playlist()`

Creates a new playlist in user's library.

**Endpoint:** `POST /v1/me/library/playlists`

**Parameters:**
- `name`: Playlist name
- `description`: Optional description

**Returns:** Apple Music playlist ID

**Request Body:**
```json
{
  "attributes": {
    "name": "Summer Vibes 2025",
    "description": "Synced from Spotify"
  }
}
```

---

### `add_tracks_to_playlist()`

Adds tracks to playlist.

**Endpoint:** `POST /v1/me/library/playlists/{id}/tracks`

**Parameters:**
- `playlist_id`: Apple Music playlist ID
- `track_ids`: List of track IDs (library track IDs, not catalog IDs)

**Notes:**
- Tracks must be in user's library first (use `add_to_library()`)
- Maximum 100 tracks per request

**Implementation:**
```python
def add_tracks_to_playlist(self, playlist_id: str, track_ids: List[str]) -> bool:
    """Add tracks to playlist."""

    # First, ensure tracks are in library
    self.add_to_library(track_ids)

    url = f"{self.BASE_URL}/v1/me/library/playlists/{playlist_id}/tracks"
    headers = self._get_headers()

    # Batch requests (100 tracks max per call)
    for i in range(0, len(track_ids), 100):
        batch = track_ids[i:i+100]

        body = {
            "data": [
                {"id": track_id, "type": "songs"}
                for track_id in batch
            ]
        }

        response = requests.post(url, headers=headers, json=body)
        response.raise_for_status()

    return True
```

---

### `search_track()`

Searches for a track using ISRC or metadata.

**Endpoints:**
- ISRC search: `GET /v1/catalog/{storefront}/songs?filter[isrc]={isrc}`
- Text search: `GET /v1/catalog/{storefront}/search?term={query}&types=songs`

**Parameters:**
- `isrc`: International Standard Recording Code
- `query`: Search query

**Returns:** `Track` object or `None`

**Implementation:**
```python
def search_track(self, isrc: str = None, query: str = None) -> Optional[Track]:
    """Search for track by ISRC or metadata."""
    headers = self._get_headers()

    # Prefer ISRC search
    if isrc:
        url = f"{self.BASE_URL}/v1/catalog/{self.storefront}/songs"
        params = {'filter[isrc]': isrc}

        response = requests.get(url, headers=headers, params=params)
        if response.ok and response.json()['data']:
            return self._parse_catalog_track(response.json()['data'][0])

    # Fallback to text search
    if query:
        url = f"{self.BASE_URL}/v1/catalog/{self.storefront}/search"
        params = {
            'term': query,
            'types': 'songs',
            'limit': 5
        }

        response = requests.get(url, headers=headers, params=params)
        if response.ok:
            results = response.json().get('results', {}).get('songs', {}).get('data', [])
            if results:
                return self._parse_catalog_track(results[0])

    return None
```

---

## Data Models

### Track Object

```python
@dataclass
class Track:
    apple_music_id: str  # Library song ID
    catalog_id: str      # Catalog song ID (for searching)
    isrc: Optional[str]
    name: str
    artists: List[str]
    album: str
    duration_ms: int
    added_at: Optional[datetime] = None
```

**Note:** Apple Music distinguishes between:
- **Library Songs**: User's personal library (`l.{id}`)
- **Catalog Songs**: Global catalog (`{id}`)

### Playlist Object

```python
@dataclass
class Playlist:
    apple_music_id: str
    name: str
    description: str
    tracks: List[Track]
    can_edit: bool
```

## Helper Methods

### `_get_headers()`

Constructs authorization headers for API requests.

```python
def _get_headers(self) -> dict:
    """Get headers for API requests."""
    headers = {
        'Authorization': f'Bearer {self.developer_token}',
        'Music-User-Token': self.user_token,
    }
    return headers
```

### `_parse_track()`

Converts Apple Music API track data to our `Track` model.

```python
def _parse_track(self, track_data: dict) -> Track:
    """Parse Apple Music track data."""
    attrs = track_data['attributes']

    return Track(
        apple_music_id=track_data['id'],
        catalog_id=attrs.get('playParams', {}).get('catalogId'),
        isrc=attrs.get('isrc'),
        name=attrs['name'],
        artists=[attrs['artistName']],
        album=attrs['albumName'],
        duration_ms=attrs['durationInMillis'],
    )
```

## Error Handling

### Common HTTP Status Codes

- **401 Unauthorized**: Invalid developer token or expired user token
- **403 Forbidden**: User hasn't authorized library access
- **404 Not Found**: Resource doesn't exist
- **429 Too Many Requests**: Rate limit exceeded
- **500 Server Error**: Apple's servers are down

### Retry Logic

```python
import time
from requests.exceptions import RequestException

def _api_call_with_retry(self, method, url, max_retries=3, **kwargs):
    """Make API call with exponential backoff retry."""

    for attempt in range(max_retries):
        try:
            response = requests.request(method, url, **kwargs)

            if response.status_code == 429:
                # Rate limited, wait and retry
                retry_after = int(response.headers.get('Retry-After', 2 ** attempt))
                time.sleep(retry_after)
                continue

            if response.status_code >= 500:
                # Server error, retry with backoff
                time.sleep(2 ** attempt)
                continue

            response.raise_for_status()
            return response

        except RequestException as e:
            if attempt == max_retries - 1:
                raise
            time.sleep(2 ** attempt)

    raise Exception(f"Max retries exceeded for {method} {url}")
```

## Challenges & Solutions

### Challenge 1: Library vs Catalog IDs

**Problem:** Apple Music has two types of IDs for the same song.

**Solution:** Store both IDs. Use catalog ID for searching, library ID for playlist operations.

### Challenge 2: Track Must Be in Library

**Problem:** Can't add track to playlist unless it's in library first.

**Solution:** Always call `add_to_library()` before `add_tracks_to_playlist()`.

### Challenge 3: User Token Expiration

**Problem:** User tokens expire and must be refreshed.

**Solution:** Catch 401 errors, re-prompt user for authentication.

## API Limits

- **Rate Limit**: Not officially documented, but appears to be ~100 requests/minute
- **Playlist Tracks**: Max 100 per request
- **Search Results**: Max 25 per request
- **Library Songs**: No hard limit

## Storefront

Apple Music content varies by country/region (storefront).

**Common Storefronts:**
- `us`: United States
- `gb`: United Kingdom
- `ca`: Canada
- `au`: Australia
- `jp`: Japan

MusicDiff auto-detects storefront from user's account.

## References

- [Apple Music API Documentation](https://developer.apple.com/documentation/applemusicapi/)
- [MusicKit JS Guide](https://developer.apple.com/documentation/musickitjs)
- [Generating Tokens](https://developer.apple.com/documentation/applemusicapi/generating_developer_tokens)
