# Database Module Documentation

## Overview

The Database module (`database.py`) manages local state storage using SQLite. It acts as the "last known good state" for the 3-way merge algorithm and stores sync history.

## Technology

- **SQLite3**: Embedded relational database
- **Location**: `~/.musicdiff/musicdiff.db`
- **Migrations**: Schema versioning for future updates

## Schema

### Entity Relationship Diagram

```
┌──────────────┐         ┌──────────────┐
│   tracks     │         │  playlists   │
│──────────────│         │──────────────│
│ isrc (PK)    │         │ id (PK)      │
│ spotify_id   │    ┌────│ spotify_id   │
│ apple_id     │    │    │ apple_id     │
│ title        │    │    │ name         │
│ artist       │    │    │ description  │
│ album        │    │    │ snapshot_id  │
│ duration_ms  │    │    │ created_at   │
│ updated_at   │    │    │ updated_at   │
└──────┬───────┘    │    └──────┬───────┘
       │            │           │
       │            │           │
       │      ┌─────▼───────────▼─────┐
       │      │  playlist_tracks      │
       │      │───────────────────────│
       └──────► playlist_id (FK)      │
              │ track_isrc (FK)       │
              │ position              │
              │ added_at              │
              └───────────────────────┘

┌──────────────┐         ┌──────────────┐
│ liked_songs  │         │   albums     │
│──────────────│         │──────────────│
│ track_isrc   │         │ id (PK)      │
│ added_at     │         │ spotify_id   │
└──────────────┘         │ apple_id     │
                         │ name         │
┌──────────────┐         │ artist       │
│  sync_log    │         └──────────────┘
│──────────────│
│ id (PK)      │         ┌──────────────┐
│ timestamp    │         │  conflicts   │
│ status       │         │──────────────│
│ changes      │         │ id (PK)      │
│ conflicts    │         │ type         │
│ details      │         │ entity_id    │
└──────────────┘         │ data         │
                         │ created_at   │
                         └──────────────┘
```

### Table Definitions

#### `tracks`

Stores normalized track data from both platforms.

```sql
CREATE TABLE tracks (
    isrc TEXT PRIMARY KEY,          -- International Standard Recording Code
    spotify_id TEXT UNIQUE,         -- Spotify track ID
    apple_id TEXT UNIQUE,           -- Apple Music library song ID
    apple_catalog_id TEXT,          -- Apple Music catalog ID
    title TEXT NOT NULL,
    artist TEXT NOT NULL,           -- Primary artist (comma-separated for multiple)
    album TEXT NOT NULL,
    duration_ms INTEGER NOT NULL,
    popularity INTEGER,             -- Spotify popularity score (0-100)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indexes for fast lookup
    INDEX idx_spotify_id (spotify_id),
    INDEX idx_apple_id (apple_id),
    INDEX idx_title_artist (title, artist)
);
```

**Notes:**
- `isrc` is primary key for cross-platform matching
- Some tracks may lack ISRC (handle gracefully)
- `updated_at` tracks when metadata was last synced

---

#### `playlists`

Stores playlist metadata.

```sql
CREATE TABLE playlists (
    id TEXT PRIMARY KEY,                -- UUID generated by MusicDiff
    spotify_id TEXT UNIQUE,             -- Spotify playlist ID
    apple_id TEXT UNIQUE,               -- Apple Music playlist ID
    name TEXT NOT NULL,
    description TEXT DEFAULT '',
    public BOOLEAN DEFAULT 0,           -- Public/Private (Spotify-specific)
    spotify_snapshot_id TEXT,           -- Spotify snapshot for change detection
    track_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_spotify_id (spotify_id),
    INDEX idx_apple_id (apple_id)
);
```

**Notes:**
- MusicDiff generates UUID to link playlists across platforms
- `snapshot_id` from Spotify API used to detect changes
- Tracks in playlist stored in `playlist_tracks` (many-to-many)

---

#### `playlist_tracks`

Junction table for playlist-track many-to-many relationship.

```sql
CREATE TABLE playlist_tracks (
    playlist_id TEXT NOT NULL,
    track_isrc TEXT NOT NULL,
    position INTEGER NOT NULL,          -- Track position in playlist (0-indexed)
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (playlist_id, track_isrc),
    FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE,
    FOREIGN KEY (track_isrc) REFERENCES tracks(isrc) ON DELETE CASCADE,

    INDEX idx_playlist (playlist_id),
    INDEX idx_track (track_isrc)
);
```

**Notes:**
- `position` maintains track order in playlist
- Cascade delete ensures orphaned entries are removed

---

#### `liked_songs`

Stores user's liked/saved songs.

```sql
CREATE TABLE liked_songs (
    track_isrc TEXT PRIMARY KEY,
    spotify_liked BOOLEAN DEFAULT 0,
    apple_liked BOOLEAN DEFAULT 0,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (track_isrc) REFERENCES tracks(isrc) ON DELETE CASCADE
);
```

**Notes:**
- Separate flags for each platform (allows tracking source)
- Simplified compared to having separate tables per platform

---

#### `albums`

Stores saved albums.

```sql
CREATE TABLE albums (
    id TEXT PRIMARY KEY,                -- UUID generated by MusicDiff
    spotify_id TEXT UNIQUE,
    apple_id TEXT UNIQUE,
    name TEXT NOT NULL,
    artist TEXT NOT NULL,
    release_date TEXT,
    total_tracks INTEGER,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_spotify_id (spotify_id),
    INDEX idx_apple_id (apple_id)
);
```

---

#### `sync_log`

Records history of sync operations.

```sql
CREATE TABLE sync_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status TEXT NOT NULL,               -- 'success', 'partial', 'failed'
    changes_applied INTEGER DEFAULT 0,
    conflicts_count INTEGER DEFAULT 0,
    duration_seconds REAL,
    details TEXT,                       -- JSON blob with detailed changes
    auto_sync BOOLEAN DEFAULT 0,        -- Was this a scheduled sync?

    INDEX idx_timestamp (timestamp)
);
```

**Status Values:**
- `success`: All changes applied, no conflicts
- `partial`: Some changes applied, conflicts skipped
- `failed`: Sync failed (API error, etc.)

**Details JSON Format:**
```json
{
  "playlists": {
    "created": 2,
    "updated": 3,
    "deleted": 1
  },
  "liked_songs": {
    "added": 45,
    "removed": 3
  },
  "albums": {
    "added": 5
  }
}
```

---

#### `conflicts`

Stores unresolved conflicts for later resolution.

```sql
CREATE TABLE conflicts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,                 -- 'playlist', 'liked_song', 'album'
    entity_id TEXT NOT NULL,            -- ID of conflicting entity
    spotify_data TEXT,                  -- JSON snapshot from Spotify
    apple_data TEXT,                    -- JSON snapshot from Apple Music
    local_data TEXT,                    -- JSON snapshot from local state
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP,
    resolution TEXT,                    -- 'spotify', 'apple', 'manual', 'skip'

    INDEX idx_type (type),
    INDEX idx_created_at (created_at),
    INDEX idx_resolved (resolved_at)
);
```

**Conflict Types:**
- `playlist`: Playlist modified on both platforms
- `liked_song`: Song liked/unliked on both platforms simultaneously
- `track_unavailable`: Track exists on one platform but not available on other

---

#### `metadata`

Stores application metadata and settings.

```sql
CREATE TABLE metadata (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Example rows:
-- ('schema_version', '1')
-- ('last_sync', '2025-10-22 13:45:12')
-- ('spotify_last_fetch', '2025-10-22 13:44:00')
```

---

## Database Class Interface

### `class Database`

Main database interface.

```python
class Database:
    def __init__(self, db_path: str = "~/.musicdiff/musicdiff.db")
    def init_schema(self) -> None
    def close(self) -> None

    # Track operations
    def upsert_track(self, track: Track) -> None
    def get_track_by_isrc(self, isrc: str) -> Optional[Track]
    def get_track_by_spotify_id(self, spotify_id: str) -> Optional[Track]
    def get_track_by_apple_id(self, apple_id: str) -> Optional[Track]

    # Playlist operations
    def upsert_playlist(self, playlist: Playlist) -> None
    def get_playlist(self, playlist_id: str) -> Optional[Playlist]
    def get_all_playlists(self) -> List[Playlist]
    def delete_playlist(self, playlist_id: str) -> None
    def set_playlist_tracks(self, playlist_id: str, track_isrcs: List[str]) -> None

    # Liked songs operations
    def set_liked_songs(self, track_isrcs: List[str], platform: str) -> None
    def get_liked_songs(self, platform: str = None) -> List[str]

    # Sync log operations
    def add_sync_log(self, status: str, changes: int, conflicts: int, details: dict) -> None
    def get_sync_history(self, limit: int = 10) -> List[dict]

    # Conflict operations
    def add_conflict(self, type: str, entity_id: str, spotify_data: dict, apple_data: dict) -> int
    def get_unresolved_conflicts(self) -> List[dict]
    def resolve_conflict(self, conflict_id: int, resolution: str) -> None

    # Metadata operations
    def get_metadata(self, key: str) -> Optional[str]
    def set_metadata(self, key: str, value: str) -> None
```

## Key Operations

### Upserting Tracks

```python
def upsert_track(self, track: Track) -> None:
    """Insert or update track data."""
    conn = sqlite3.connect(self.db_path)
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO tracks (isrc, spotify_id, apple_id, title, artist, album, duration_ms)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(isrc) DO UPDATE SET
            spotify_id = COALESCE(excluded.spotify_id, spotify_id),
            apple_id = COALESCE(excluded.apple_id, apple_id),
            title = excluded.title,
            artist = excluded.artist,
            album = excluded.album,
            duration_ms = excluded.duration_ms,
            updated_at = CURRENT_TIMESTAMP
    """, (track.isrc, track.spotify_id, track.apple_id, track.title,
          track.artist, track.album, track.duration_ms))

    conn.commit()
    conn.close()
```

**Notes:**
- Uses `ON CONFLICT DO UPDATE` (upsert pattern)
- `COALESCE` preserves existing IDs if new value is NULL

---

### Setting Playlist Tracks

```python
def set_playlist_tracks(self, playlist_id: str, track_isrcs: List[str]) -> None:
    """Replace all tracks in a playlist."""
    conn = sqlite3.connect(self.db_path)
    cursor = conn.cursor()

    # Delete existing tracks
    cursor.execute("DELETE FROM playlist_tracks WHERE playlist_id = ?", (playlist_id,))

    # Insert new tracks with positions
    for position, track_isrc in enumerate(track_isrcs):
        cursor.execute("""
            INSERT INTO playlist_tracks (playlist_id, track_isrc, position)
            VALUES (?, ?, ?)
        """, (playlist_id, track_isrc, position))

    # Update track count
    cursor.execute("""
        UPDATE playlists SET track_count = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
    """, (len(track_isrcs), playlist_id))

    conn.commit()
    conn.close()
```

---

## Migrations

Schema migrations tracked via `metadata` table.

```python
def migrate(self) -> None:
    """Run database migrations."""
    current_version = int(self.get_metadata('schema_version') or 0)

    migrations = [
        self._migrate_to_v1,
        self._migrate_to_v2,
        # Add new migrations here
    ]

    for version, migration in enumerate(migrations, start=1):
        if version > current_version:
            migration()
            self.set_metadata('schema_version', str(version))
```

## Best Practices

1. **Use Transactions**: Wrap multi-statement operations in transactions
2. **Indexes**: Add indexes for frequently queried columns
3. **Foreign Keys**: Enable foreign key constraints (`PRAGMA foreign_keys = ON`)
4. **WAL Mode**: Use Write-Ahead Logging for better concurrency (`PRAGMA journal_mode=WAL`)
5. **Backups**: Periodically backup `musicdiff.db` file

## Testing

Mock database for tests:

```python
class MockDatabase(Database):
    def __init__(self):
        super().__init__(":memory:")  # In-memory DB
        self.init_schema()
```

## References

- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Python sqlite3 Module](https://docs.python.org/3/library/sqlite3.html)
